Структура проекта
=================

Корневая директория
-------------------

Структура папок корневой директории описана в Redmine:
`Создание и работа над проектом
<http://redmine.pin/easy_knowledge_stories/80>`__.


Папка emb
---------

В папке **emb** располагается исходный код ВПО (встраиваемого
программного обеспечения). Структура папки **emb** частично
продиктована CMake-ом, который используется для сборки проекта.

Основные файлы и папки **emb**:

- **.gitignore** - основной список файлов для игнорирования
  git-ом;

- **CMakeLists.txt** — корневой CMakeLists.txt;

- **.clang-format** — файл настроек для ClangFormat

- **lib** — содержит скомпилированные библиотеки, а так
  же их *Config.cmake* файлы в поддериктории **cmake**.
  Все файлы и директории добавлены в игнорлист,
  кроме самой папки **cmake**;

- **include** — содержит заголовочные файлы скомпилированных
  и установленных библиотек; Все файлы этой директории должны
  быть добавлены в игнорлист;

- **bin** — содержит бинарные файлы (elf, bin) которые были
  сгенерированы в процессе компиляции. Файлы попадают в эту
  директорию после запуска ``make install`` для проекта при
  указании этой директории в качестве ``CMAKE_INSTALL_PREFIX``;

- **cmake** — содержит *.cmake*-файлы для упрощённого менеджмента
  CMake структуры проекта. Данная папка должна подключаться как
  git `submodule` репозитория `CMake files <https://gitlab.pin
  /thirdpin_team/cmake-files>`__;

- **patches** - содержит git-патчи для 3th party библиотек,
  которые компилируются в процессе компиляции проекта
  (например для `libopencm3 <https://github.com/libopencm3/
  libopencm3>`__);

- **util** — содержит доп. утилиты для работы с проектом,
  *launch*-файлы для работы с отладчиком в Eclipse/TrueStudio,
  а так же `файлы описывающие регистры
  <https://www.keil.com/pack/doc/CMSIS/SVD/html/svd_Format_pg.html>`__
  периферии МК от STM32. Скачать можно здесь: `posborne/cmsis-svd
  <https://github.com/posborne/cmsis-svd/tree/master/data/STMicro>`__;
  эти файлы используется расширением Cortex Debug для VS Code;

- **.vscode** [опционально] — может хранить в себе файлы для
  конфигурации `VS Code <https://code.visualstudio.com/>`__  и
  его расширений. Может включать такие файлы как:

  - **c_cpp_properties.json** —
    настройка `C/C++ расширения
    <https://github.com/microsoft/vscode-cpptools/
    blob/master/Documentation/Getting%20started%20with
    %20IntelliSense%20configuration.md>`__
  - **cmake-kits.json** — настройка toolchain для
    `расширения CMake <https://vector-of-bool.github.io/
    docs/vscode-cmake-tools/kits.html>`__
  - **launch.json** — настройка `отладки <https://code.
    visualstudio.com/docs/editor/debugging>`__ приложения
    для `расширения Cortex Debug <https://marketplace.
    visualstudio.com/items?itemName=marus25.cortex-debug>`__
  - **.gitignore** — игнорируемые Git-ом файлы, должны быть
    включены все файлы, кроме перечисленных выше;

- **.cproject**, **.project** [опционально] — файлы проекта
  Eclipce/TrueStudio, появляются только после импорта
  папки с проектом в IDE, инструкция тут: `Настройка и
  использование CMake <http://redmine.pin/easy_knowledge_stories
  /116>`__;

- **cmake-variants.yaml** [опционально] — файл, описывающий
  возможные конфигурации сборки CMake и соответствующие им
  ``-D`` флаги;

- **test** [зарезервировано] - данная папка зарезервирована для
  будущего использования.


Структура CMake-проекта
-----------------------

    Если вы не знаете, что такое CMake, не разбираетесь в понятиях,
    которыми он оперирует, то вам необходимо разобраться. Без этого
    полноценное понимание данного пункта, а так же правильное
    использование шаблона, невозможно. Ссылки на статьи для изучения
    CMake можно найти вот тут: `Настройка и использование CMake
    <http://redmine.pin/easy_knowledge_stories/116>`__


Для кроссплатформенной и унифицированной компиляции проекта
используется `CMake <https://en.wikipedia.org/wiki/CMake>`__.
Обязательным требованием к использованию данного шаблона является
его понимание, а так же наличие в ``PATH`` пути до ``cmake.exe`` —
запускаемого файла CMake. Требуемая версия: 3.13 и выше.

Любой проект состоит из **проекта верхнего уровня** и **подпроектов**.
Обычно названия проекта верхнего уровня и подпроектов не совпадают.
Так же в одном репозитории не желательно иметь больше одного подпроекта.

emb
+++

Основной код проекта находиться в папке **emb/src**, однако корнем
CMake проекта является **emb** — в ней находится корневой CMake-файл.
Данный файл содержит в себе включение всех необходимых кросспроектных
макросов и библиотек. Данный файл не изменяется между проектами, за
исключением имени *проекта верхнего уровня*, указанного в нём.

emb/src
+++++++

В корневом ``CMakeLists.txt`` включается в сбоку папка **src**.
Данная папка содержит в себе все библиотеки, сборка которых
осуществляется в процессе компиляции проекта, а так же все
подпроекты, соответствующие созданному проекту.

**Добавление библиотек** к сборке осуществляется с помощью
команды ``add_subdirectory``. Если библиотека не поддерживает сборку
с помощью CMake, то необходимо (на примере библиотеки
`yxml <https://code.blicky.net/yorhel/yxml>`__):

1. Инкапсулировать библиотеку дополнительно в директорию с именем
   библиотеки. Например, изначальная если изначальная структура
   библиотеки следующая:

   .. code-block::

     yxml
      › yxml.c
      › yxml.h
      › ...

   необходимо инкапсулировать библиотеку в папку с именем **yxml**,
   т.е.:

   .. code-block::

      yxml
        yxml
          › yxml.c
          › yxml.h
          › ...

2. Создать файл ``yxml/CMakeLists.txt``, в нём создать цель сборки
   (target) для библиотеки. В качестве имени цели сборки использовать
   название библиотеки. Указать папку ``yxml`` в качестве пути до
   заголовочных файлов:

   .. code-block:: cmake

       target_include_directories(yxml
           PUBLIC
               ${CMAKE_CURRENT_LIST_DIR}
           PRIVATE
               ${CMAKE_CURRENT_LIST_DIR}/yxml
       )

   Таким образом, при линковке данной библиотеки к другим целям
   сборки будет возможность обратиться к заголовочным файлам
   библиотеки используя префикс: :cpp:`#include <yxml/yxml.h>`.

   Секция `PRIVATE` необходима для того, чтобы библиотека могла
   найти собственные заголовочные файлы (не актуально для
   библиотек, в которых используются относительные пути до
   заголовочных файлов). Секция `PRIVATE` возможна только для
   статической библиотеки.

3. Не header-only библиотеки предпочтительно делать статическими
   (``STATIC``).

4. Добавить библиотеку с помощью команды ``add_subdirectory(yxml)``
   в файле ``/emb/src/CMakeLists.txt``.

    Исключение составляет библиотека `OpenCM3`. Для её компиляции
    необходимо использовать макрос ``add_libopencm3_for``. Пример
    использования макроса есть в файле ``/emb/src/CMakeLists.txt``.

**Добавление подпроектов** к сборке происходит аналогично библиотекам
с поддержкой CMake. Структура типового подпроекта описана ниже.


emb/src/<subproject>
++++++++++++++++++++

Основная папка, в которой происходит работа с кодом. Пример типового
``CMakeLists.txt`` для подпроекта представлен в папке
**emb/src/template**.

С структуру подпроекта входят:

- **include/<project_name>** — здесь находятся *ПУБЛИЧНЫЕ*
  заголовочные файлы, т.е. те, которые могут быть
  использованы в другом подпроекте;

- **ldscripts** содержит ld-скрипты для линкера;

- **src** содержит все исходные и *ПРИВАТНЫЕ* заголовочные файлы;

- **CMakeLists.txt** — корневой CMake-файл подпроекта.

В любом подпроекте папка **include** должны быть указана
в качестве *ПУБЛИЧНОГО* пути до заголовочных файлов, а папка
**src** в качестве *ПРИВАТНОГО*. Это позволит скрыть ненужные
заголовочные файлы, но при этом использовать префиксы внутри
подпроекта.

    При работе над проектом не следует пользоваться относительными
    путями до заголовочных фалов. Всегда используйте пути
    с префиксом, например :cpp:`#include <hw/HwStub.cpp>`.

Каждый подпроект должен иметь собственную версию. Версия генерируется
в процессе компиляции и записывается в файл
**include/<project_name>/version.h**. Для генерации версии используется
макрос ``add_version_target(${PROJECT_NAME})``, который создаёт цель
вида ``${PROJECT_NAME}::version``. Эта цель должна быть прилинкована
к основной цели подпроекта.

В имеющейся структуре подпроектов не подозревается наследование
зависимостей между подпроектами, поэтому все прилинкованные библиотеки
должны находиться в секции ``PRIVATE``.
