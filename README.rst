.. role:: cpp(code)
   :language: cpp

===============
Проект «Шаблон»
===============

----------------------------------------
Шаблон для упрощённого создания проектов
----------------------------------------


1 Структура проекта
===================

1.1 Корневая директория
-----------------------

Структура папок корневой директории описана в Redmine:
`Создание и работа над проектом
<http://redmine.pin/easy_knowledge_stories/80>`__.


1.2 Папка emb
-------------

В папке **emb** располагается исходный код ВПО (встраиваемого
программного обеспечения). Структура папки **emb** частично
продиктована CMake-ом, который используется для сборки проекта.

Основные файлы и папки **emb**:

- **.gitignore** - основной список файлов для игнорирования
  git-ом;

- **CMakeLists.txt** — корневой CMakeLists.txt;

- **.clang-format** — файл настроек для ClangFormat

- **lib** — содержит скомпилированные библиотеки, а так
  же их *Config.cmake* файлы в поддериктории **cmake**.
  Все файлы и директории добавлены в игнорлист,
  кроме самой папки **cmake**;

- **include** — содержит заголовочные файлы скомпилированных
  и установленных библиотек; Все файлы этой директории должны
  быть добавлены в игнорлист;

- **bin** — содержит бинарные файлы (elf, bin) которые были
  сгенерированы в процессе компиляции. Файлы попадают в эту
  директорию после запуска ``make install`` для проекта при
  указании этой директории в качестве ``CMAKE_INSTALL_PREFIX``;

- **cmake** — содержит *.cmake*-файлы для упрощённого менеджмента
  CMake структуры проекта. Данная папка должна подключаться как
  git `submodule` репозитория `CMake files <https://gitlab.pin
  /thirdpin_team/cmake-files>`__;

- **patches** - содержит git-патчи для 3th party библиотек,
  которые компилируются в процессе компиляции проекта
  (например для `libopencm3 <https://github.com/libopencm3/
  libopencm3>`__);

- **util** — содержит доп. утилиты для работы с проектом,
  *launch*-файлы для работы с отладчиком в Eclipse/TrueStudio,
  а так же `файлы описывающие регистры
  <https://www.keil.com/pack/doc/CMSIS/SVD/html/svd_Format_pg.html>`__
  периферии МК от STM32. Скачать можно здесь: `posborne/cmsis-svd
  <https://github.com/posborne/cmsis-svd/tree/master/data/STMicro>`__;
  эти файлы используется расширением Cortex Debug для VS Code;

- **.vscode** [опционально] — может хранить в себе файлы для
  конфигурации `VS Code <https://code.visualstudio.com/>`__  и
  его расширений. Может включать такие файлы как:

  - **c_cpp_properties.json** —
    настройка `C/C++ расширения
    <https://github.com/microsoft/vscode-cpptools/
    blob/master/Documentation/Getting%20started%20with
    %20IntelliSense%20configuration.md>`__
  - **cmake-kits.json** — настройка toolchain для
    `расширения CMake <https://vector-of-bool.github.io/
    docs/vscode-cmake-tools/kits.html>`__
  - **launch.json** — настройка `отладки <https://code.
    visualstudio.com/docs/editor/debugging>`__ приложения
    для `расширения Cortex Debug <https://marketplace.
    visualstudio.com/items?itemName=marus25.cortex-debug>`__
  - **.gitignore** — игнорируемые Git-ом файлы, должны быть
    включены все файлы, кроме перечисленных выше;

- **.cproject**, **.project** [опционально] — файлы проекта
  Eclipce/TrueStudio, появляются только после импорта
  папки с проектом в IDE, инструкция тут: `Настройка и
  использование CMake <http://redmine.pin/easy_knowledge_stories
  /116>`__;

- **cmake-variants.yaml** [опционально] — файл, описывающий
  возможные конфигурации сборки CMake и соответствующие им
  ``-D`` флаги;

- **test** [зарезервировано] - данная папка зарезервирована для
  будущего использования.


1.3 Структура CMake-проекта
---------------------------

    Если вы не знаете, что такое CMake, не разбираетесь в понятиях,
    которыми он оперирует, то вам необходимо разобраться. Без этого
    полноценное понимание данного пункта, а так же правильное
    использование шаблона, невозможно. Ссылки на статьи для изучения
    CMake можно найти вот тут: `Настройка и использование CMake
    <http://redmine.pin/easy_knowledge_stories/116>`__


Для кроссплатформенной и унифицированной компиляции проекта
используется `CMake <https://en.wikipedia.org/wiki/CMake>`__.
Обязательным требованием к использованию данного шаблона является
его понимание, а так же наличие в ``PATH`` пути до ``cmake.exe`` —
запускаемого файла CMake. Требуемая версия: 3.13 и выше.

Любой проект состоит из **проекта верхнего уровня** и **подпроектов**.
Обычно названия проекта верхнего уровня и подпроектов не совпадают.
Так же в одном репозитории не желательно иметь больше одного подпроекта.

emb
+++

Основной код проекта находиться в папке **emb/src**, однако корнем
CMake проекта является **emb** — в ней находится корневой CMake-файл.
Данный файл содержит в себе включение всех необходимых кросспроектных
макросов и библиотек. Данный файл не изменяется между проектами, за
исключением имени *проекта верхнего уровня*, указанного в нём.

emb/src
+++++++

В корневом ``CMakeLists.txt`` включается в сбоку папка **src**.
Данная папка содержит в себе все библиотеки, сборка которых
осуществляется в процессе компиляции проекта, а так же все
подпроекты, соответствующие созданному проекту.

**Добавление библиотек** к сборке осуществляется с помощью
команды ``add_subdirectory``. Если библиотека не поддерживает сборку
с помощью CMake, то необходимо (на примере библиотеки
`yxml <https://code.blicky.net/yorhel/yxml>`__):

1. Инкапсулировать библиотеку дополнительно в директорию с именем
   библиотеки. Например, изначальная если изначальная структура
   библиотеки следующая:

   .. code-block:: 

     yxml
      › yxml.c
      › yxml.h
      › ...

   необходимо инкапсулировать библиотеку в папку с именем **yxml**,
   т.е.:

   .. code-block:: 

      yxml
        yxml
          › yxml.c
          › yxml.h
          › ...

2. Создать файл ``yxml/CMakeLists.txt``, в нём создать цель сборки
   (target) для библиотеки. В качестве имени цели сборки использовать
   название библиотеки. Указать папку ``yxml`` в качестве пути до
   заголовочных файлов:

   .. code-block:: cmake

       target_include_directories(yxml
           PUBLIC
               ${CMAKE_CURRENT_LIST_DIR}
           PRIVATE
               ${CMAKE_CURRENT_LIST_DIR}/yxml
       )

   Таким образом, при линковке данной библиотеки к другим целям
   сборки будет возможность обратиться к заголовочным файлам
   библиотеки используя префикс: :cpp:`#include <yxml/yxml.h>`.

   Секция `PRIVATE` необходима для того, чтобы библиотека могла
   найти собственные заголовочные файлы (не актуально для
   библиотек, в которых используются относительные пути до
   заголовочных файлов). Секция `PRIVATE` возможна только для
   статической библиотеки.

3. Не header-only библиотеки предпочтительно делать статическими
   (``STATIC``).

4. Добавить библиотеку с помощью команды ``add_subdirectory(yxml)``
   в файле ``/emb/src/CMakeLists.txt``.

    Исключение составляет библиотека `OpenCM3`. Для её компиляции
    необходимо использовать макрос ``add_libopencm3_for``. Пример
    использования макроса есть в файле ``/emb/src/CMakeLists.txt``.

**Добавление подпроектов** к сборке происходит аналогично библиотекам
с поддержкой CMake. Структура типового подпроекта описана ниже.


emb/src/<subproject>
++++++++++++++++++++

Основная папка, в которой происходит работа с кодом. Пример типового
``CMakeLists.txt`` для подпроекта представлен в папке
**emb/src/template**.

С структуру подпроекта входят:

- **include/<project_name>** — здесь находятся *ПУБЛИЧНЫЕ*
  заголовочные файлы, т.е. те, которые могут быть
  использованы в другом подпроекте;

- **ldscripts** содержит ld-скрипты для линкера;

- **src** содержит все исходные и *ПРИВАТНЫЕ* заголовочные файлы;

- **CMakeLists.txt** — корневой CMake-файл подпроекта.

В любом подпроекте папка **include** должны быть указана
в качестве *ПУБЛИЧНОГО* пути до заголовочных файлов, а папка
**src** в качестве *ПРИВАТНОГО*. Это позволит скрыть ненужные
заголовочные файлы, но при этом использовать префиксы внутри
подпроекта.

    При работе над проектом не следует пользоваться относительными
    путями до заголовочных фалов. Всегда используйте пути
    с префиксом, например :cpp:`#include <hw/HwStub.cpp>`.

Каждый подпроект должен иметь собственную версию. Версия генерируется
в процессе компиляции и записывается в файл
**include/<project_name>/version.h**. Для генерации версии используется
макрос ``add_version_target(${PROJECT_NAME})``, который создаёт цель
вида ``${PROJECT_NAME}::version``. Эта цель должна быть прилинкована
к основной цели подпроекта.

В имеющейся структуре подпроектов не подозревается наследование
зависимостей между подпроектами, поэтому все прилинкованные библиотеки
должны находиться в секции ``PRIVATE``.


2. How to use
=============

Предположем, ваш проект верхнего уровня называется ``my_project``
и имеет под проект ``my_subproject``. Ниже представлены шаги,
которые необходимо проделать, чтобы создать требуемый проект из
шаблона.

1. Клонировать шаблон в папку с названием будущего проекта:

   .. code-block:: bash

        git clone --recurse-submodules git@gitlab.pin:thirdpin_team/project-template.git myproject

2. Проект по-умолчанию включает в себя в качестве submodules
   следующие репозитории:

   - **libopencm3** (/emb/src/libopencm3) — опциональная
     библиотека `OpenCM3 <https://libopencm3.org/>`__ для
     работы с периферией контроллеров;

   - **etl** (/emb/src/etl) — опциональная библиотека
     `Embedded Template Library <https://www.etlcpp.com/>`__
     с множеством полезных классов заменяющих и
     дополняющих std;

   - **yxml** (/emb/src/yxml) — опциональная библиотека
     `yxml <https://code.blicky.net/yorhel/yxml>`__
     для парсинга xml;

   - **cmake** (/cmake) — **обязательный** submodule с
     CMake-файлами необходимыми для сборки проекта и
     библиотек.

   **ВАЖНО**: если вы хотите убрать из сборки одну из
   представленных выше опциональных бибилотек необходимо
   сделать следующее (на примере yxml):

   1) деинициализировать submodule:

      .. code-block:: bash

        git submodule deinit emb/src/yxml/yxml

   2) удалить папку с submodule;

      .. code-block:: bash

        git rm -r emb/src/yxml

   3) удалить строчку `add_subdirectory(yxml)`
      в файле **/emb/src/CMakeLists.txt**;
   4) сделать коммит с удалённым модулем;
   5) удалить папку ``/.git/modules/emb/src/yxml/yxml``.

3. Изменить ``remote`` локального репозитория на новый
   заранее созданный удалённый пустой репозиторий:

   .. code-block:: bash

       git remote set-url origin <your-git-repo-url>

4. Поменять имя проекта верхнего уровня в файле
   ``/emb/CMakeLists.txt``.

        Для для именования проектов и подпроектов лучше
        использовать латинские буквы при необходимости
        разделённые символом подчёркивания "\_". Символ
        дефиса "-" для разделения слов лучше не использовать.

        Имя основной цели проекта или подпроекта должно
        совпадать с именем проекта и подпроекта соответственно.

5. Папку ``/emb/src/template`` переименовать в папку с именем
   вашего проекта; добавить переименованную папку в
   ``/emb/src/CMakeLists.txt``.

6. В файле ``/emb/src/myproject/CMakeLists.txt`` необходимо
   изменить ``project(...)`` на имя вашего подпроекта.

7. Создать папку ``/emb/src/myproject/include/myproject``, в
   которую будет генерироваться файл с версией.

8. Удалить из ``target_link_libraries`` у подпроекта лишние
   библиотеки.

9. Удалить из **main.cpp** лишний код.

10. Добавить файл линкера **myproject.ld** в папку
    **/emb/src/myproject/**.

10. Собрать (см. п. 3).

12. Исправить файл **/.gitlab-ci.yml**: исправить пути до
    компилируемых бинарников.

11. Сделать commit, push.


3. How to compile
=================

3.1 Необходимые зависимости
---------------------------

Основные зависимости для сборки любого проекта это:

- `CMake <https://cmake.org/>`__ [in PATH] — основной
  инструмент для организации и сборки проекта;

- `Ninja <https://ninja-build.org/>`__ [in PATH] — более
  легковесная, быстрая и портативная альтернатива `make
  <https://ru.wikipedia.org/wiki/Make>`__;

- компилятор (любой из) [in PATH]:

  - `GNU ARG GCC <https://developer.arm.com/
    tools-and-software/open-source-software/developer-tools
    /gnu-toolchain/gnu-rm>`__ — форк ``gcc``, поставляемый
    компанией ARM;

  - `Clang <http://releases.llvm.org/download.html#8.0.0>`__ —
    современный компилятор, пришедший на замену ``gcc``,
    поддерживает компиляцию под ARM;

- `Windows Subsystem for Linux (WSL) <https://docs.microsoft.
  com/ru-ru/windows/wsl/install-win10>`__ [только для Windows] —
  слой совместимости для запуска Linux-приложений, необходим
  для сборки библиотеки OpenCM3. Так же требуется установить
  следующие пакеты в WSL:

  - make
  - python
  - `gcc-arm-embedded <https://launchpad.net/
    ~team-gcc-arm-embedded/+archive/ubuntu/ppa>`__
  - git


3.2 Порядок сборки
------------------

    Далее будет описана сборка исключительно с использованием консоли.
    Описание настройки сборки из-под IDE ищите в Redmine.

Перед началом сборки необходимо создать папку **/emb/build** и перейти
в неё.


Конфигурация
++++++++++++

Для запуска конфигурации необходимо указать флаги:

- `\-DCMAKE_TOOLCHAIN_FILE` — пусть до toolchain-файла, выбирается
  в зависимости от компилятора. Для Clang это
  "cmake/toolchains/toolchain-clang.cmake";

- `\-DCMAKE_BUILD_TYPE` — тип сборки два основных это *Debug* и
  *Release*. В последнем во время компиляции добавляются флаги
  оптимизации (обычно O3), убираются символы отладки из бинарика
  и добавляется дефайн :cpp:`NDEBUG`. Другие типы сборки можно
  посмотреть в `документации CMake <https://cmake.org/cmake/help
  /git-stage/variable/CMAKE_BUILD_TYPE.html>`__.

- `\-DTOOLCHAIN_CORTEX_CONFIG` — выбор ядра, для которого
  осуществляется компиляция. По-умолчанию, это *cortex-m3*,
  но возможны варианты *cortex-m0*, *cortex-m4* и *cortex-a9*.

- `\-GNinja` — выбор генератора, т.е. по сути это выбор формата
  генерируемых Makefile-ов. Так как мы используем Ninja, то флаг
  соответствующий;

- `\-DCMAKE_INSTALL_PREFIX` [опционально] — место установки
  бинарников и сопровождающих файлов. Может быть использовано
  при создании релизов, но для сборки не обязательно.

Итого получаем:

.. code-block:: bash

    mrdir build
    cd build
    cmake -DCMAKE_TOOLCHAIN_FILE=../cmake/toolchains/toolchain-clang.cmake -DTOOLCHAIN_CORTEX_CONFIG=cortex-m4 -DCMAKE_BUILD_TYPE=Release -GNinja ..

Если для запуска используется **PowerShell** необходимо указывать
абсолютный путь до toolchain-файла. Последние две точки в команде
указывают на расположение корневого `CMakeLists.txt` файла.


Сборка
++++++

Для сборки необходимо запустить следующую команду, находясь
в папке **emb/src/build**:

.. code-block:: bash

    cmake --build . --target all

Для сборки конкретной целим можно вместо ``all`` указать
имя цели, например

.. code-block:: bash

    cmake --build . --target my_subproject

Для сборки и установки используется команда

.. code-block:: bash

    cmake --build . --target install

3.2 Gitlab CI
-------------

Для описания порядка работы с артефактами используется файл
**.gitlab-ci.yml**. В данном шаблоне представлена простейшая
его реализация, которая позволяет собрать проект на сервере
Gitlab и скопировать полученные артефакты. В файле необходимо
исправить все пути до артефактов на актуальные и добавить
необходимые, если подпроектов больше, чем один.

В дальнейшем данный раздел будет описан подробнее, а шаблонный
**.gitlab-ci.yml** будет доработан.
