stages:
  - build
  - release
  - publish

variables:
  PROJECT_NAME: "template"
  TOOLCHAIN_PATH: ./external/cmake/toolchains
  GIT_STRATEGY: fetch
  GIT_CHECKOUT: "true"
  GIT_SUBMODULE_STRATEGY: recursive
  BUILDER_IMAGE: "registry.gitlab.thirdpin.io/devops/thirdpin-builder:v0.8"

# Build with Clang.
build-clang:
  stage: build
  image: ${BUILDER_IMAGE}
  variables:
    CMAKE_TOOLCHAIN_FILE: ${TOOLCHAIN_PATH}/toolchain-clang.cmake

  script:
    - cmake -Bbuild -G Ninja -DCMAKE_TOOLCHAIN_FILE="${CMAKE_TOOLCHAIN_FILE}" -DCMAKE_BUILD_TYPE=Release .
    - cd build
    - cmake --build .
    - cd ../

    - mkdir -p ./bin

    - mv ./build/src/$PROJECT_NAME.hex ./bin
    - mv ./build/src/$PROJECT_NAME.elf ./bin
    - mv ./build/src/$PROJECT_NAME.bin ./bin

  artifacts:
    paths:
      - bin/$PROJECT_NAME.hex
      - bin/$PROJECT_NAME.elf
      - bin/$PROJECT_NAME.bin
      - include/$PROJECT_NAME/version.hpp
      - docs/changelog.txt

# Build with GCC.
build-gcc:
  extends: build-clang
  variables:
    CMAKE_TOOLCHAIN_FILE: $TOOLCHAIN_PATH/toolchain-none-eabi-arm-generic.cmake


# Check if a version is correct and make a release archive.
#
#   ATTENTION: Remove dot before the job name for a real project.
#
.release:
  stage: release
  image: ${BUILDER_IMAGE}
  variables:
    GIT_STRATEGY: none

  # Take only clang generated binaries
  dependencies:
    - build-clang 

  only:
    - tags

  before_script:
    - mkdir ci
    - cd ci

    # Fetch a special script to make a release
    - git init
    - git remote add origin https://gitlab+deploy-token-6:PQE6hZNbq1V_nrEcHvfJ@gitlab.thirdpin.io/devops/ci-release-maker-bash
    - git fetch
    - git checkout origin/master -- make_release.sh

    - cd ..

    - chmod +x ci/make_release.sh

  script:
    - mkdir release
    - >
      ./ci/make_release.sh
      --changelog ./docs/changelog.txt
      --binaries
      "bin/$PROJECT_NAME.hex
      bin/$PROJECT_NAME.elf
      bin/$PROJECT_NAME.bin"
      --files_with_version
      "include/$PROJECT_NAME/version.hpp"
      --output_directory release
      || exit 1

    - mv release/${CI_COMMIT_TAG}*.zip ./

    # Rename final archive
    - find ${CI_COMMIT_TAG}*.zip -type f -exec mv -i {} ${PROJECT_NAME}_{} \;

  artifacts:
    paths:
      - ${PROJECT_NAME}_${CI_COMMIT_TAG}*.zip


# Publish the release to the artifact storage (Yandex Disk).
#
#   ATTENTION: Remove dot before the job name for a real project.
#
.publish:
  stage: publish
  image: registry.gitlab.thirdpin.io/devops/yandex-disk-cmd/master
  variables:
    GIT_STRATEGY: none
    # Variables below must be set in Gitlab project settings
    YDCMD_TOKEN: ${YDCMD_TOKEN}
    REDMINE_API_KEY: ${REDMINE_API_KEY}
    REDMINE_PROJECT_ID: ${REDMINE_PROJECT_ID}

  dependencies:
    - release

  only:
    - tags

  before_script:
    - mkdir ci
    - cd ci

    # Fetch a special script to extract a Redmine project structure
    - git init
    - git remote add origin https://gitlab+deploy-token-7:719YUz1paXewJemyrx3i@gitlab.thirdpin.io/devops/redmine-project-tree.git
    - git fetch
    - git checkout origin/master -- requirements.txt
    - git checkout origin/master -- tree-getter.py
    - pip install -r requirements.txt

    - chmod +x tree-getter.py

    - ./tree-getter.py ${REDMINE_PROJECT_ID} > project_path.txt
    - echo "Project path is $(cat project_path.txt)"

    - cd ..

  script:
    - >
      ydcmd put ${PROJECT_NAME}_${CI_COMMIT_TAG}*.zip
      "disk:/Deploy/$(cat ci/project_path.txt)/${PROJECT_NAME}_${CI_COMMIT_TAG}.zip"
